<!DOCTYPE html>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<!--<script src="//cdnjs.cloudflare.com/ajax/libs/twemoji/1.3.2/twemoji.min.js"></script>-->
<!--<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js"></script>-->
<script src="jquery-1.10.2.min.js"></script>
<script src="d3.min.js"></script>

<style>
    body {
        width: 600px;
    }
    
    .node circle {
        cursor: pointer;
        /*stroke: #3182bd;*/
        /*stroke-width: 1.5px;*/
    }
    
    text {
        font: 28px sans-serif;
        pointer-events: none;
        text-anchor: middle;
    }
    
    .link {
        stroke: #999;
        stroke-opacity: .6;
    }
</style>

<body>
    <!--<script src="//d3js.org/d3.v3.min.js"></script>-->
    <div class="button-hash" id="0">#Broncos</div>
    <div class="button-hash" id="1">#KeepPounding</div>

    <script>
        
        function build() {
           
            var width = Math.max(320, window.innerWidth),
                height = 1000,
                padding = 1, // separation between same-color nodes
                clusterPadding = 2, // separation between different-color nodes
                maxRadius = 20,
                mult = width / 320;

            var color = d3.scale.category10();

            var svg = d3.select("body").append("svg")
                .attr("width", width)
                .attr("height", height);

            d3.json("nodes.json", function(error, graph) {
                
                if (error) throw error;
                
                
                //finds all the date chunks
                var datetimeUnique = graph.nodes.map(function(d) {
                    return d.datetime;  
                }).filter((value, index, self) => self.indexOf(value) === index)
                
                var groupArray = graph.nodes.map(function(d) {
                    return d.group;  
                }).filter((value, index, self) => self.indexOf(value) === index)
                
                //gets date chunks for interface
                var a = new Date(datetimeUnique[0])
                
                
                //filters date chunks
                graph.nodes = graph.nodes.filter(function(d) {
                    return d.datetime > datetimeUnique[0]
                })


                
                outArray = []
                groupArray.forEach(function(value, index) {
                    
                    var groupNodes = graph.nodes.filter(function(d) {
                        return d.group === value
                    })
                    
                    var nodesArray = groupNodes.map(function(d) {return d.name;}).filter((value, index, self) => self.indexOf(value) === index)

                    nodesArray.forEach(function(d) {
                        outArray.push({"group": value, "name": d, "radius": groupNodes.filter(function(e) {return e.name === d }).map(function(e){ return e.radius; }).reduce(function(p,c) {return p + c; }),
                        "text": groupNodes.filter(function(e) {return e.name === d }).map(function(e){ return e.text; }).reduce(function(p,c) {return p.concat(c); })
                        })

                    })
                })
                
                console.log(outArray) // STOPPED!
               
                var max = graph.nodes.reduce(function(prev,cur) {

                    return Math.max(prev, cur.radius)
                }, 0)


                var m = 2
                var clusters = new Array();

                //finds the largest node in cluster
                outArray.forEach(function(d, i) {
                    
                    outArray[i].radius = Math.sqrt((d.radius*mult)/Math.PI*50) 
                    outArray[i].y = d.group * height / m
                    if (!clusters[d.group] || (d.radius > clusters[d.group].radius)) 
                        {
                            clusters[d.group] = d;
                        }
                    maxRadius = Math.max(maxRadius, d.radius)
                })
                outArray = outArray.filter(function(d) {
                    return d.radius > 0;
                })
                
                
                
                var force = d3.layout.force()
                    .gravity(.01)
                    .charge(-2)
                    .friction(.8)
                    .size([width, height])
                    .nodes(outArray)
                    .start();

                    // var node = svg.selectAll(".node")
                    //     .data(graph.nodes)
                    //     .enter()
                    //     .append('g')
                    //     .attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; }) 
                    //     .attr('class', 'node')
                    //     .call(force.drag);
                        
                    // node.append('circle')
                    //     .attr('r', function(d) {
                    //                 return d.radius;
                    //             })
                    //             .style('fill', function(d) {
                    //                 return color(d.group)
                    //             })
                        
                    // node.append('image')
                    //     .attr('xlink:href', function(d) {
                            
                    //         if (d.name.indexOf('.png') !== -1) {
                    //             return 'img-apple-160/' + d.name
                    //         }
                    //         else {
                    //             return null
                    //         }
                    //     })
                    //     .attr('width', function(d) {return d.radius + 'px'})
                    //     .attr('height', function(d) {return d.radius + 'px'})
                    //     .attr('x', function(d) {return -d.radius/2 + 'px'})
                    //     .attr('y', function(d) {return -d.radius/2 + 'px'})
                    
                    // node.filter(function(d){
                    //         return d.name.indexOf('.png') === -1
                    //     })
                    //     .append('text')
                    //     .text(function(d) { return d.name;})
                    //     .attr('width', function(d) {return d.radius + 'px'})
                    //     .attr('height', function(d) {return d.radius + 'px'})
                    //     .attr('x', function(d) {return 0 + 'px'})
                    //     .attr('y', function(d) {return 5 + 'px'})
                    //     .style('font-size', '10px')
                    //     .attr('text-anchor', 'middle')
                
                        
                    //cools off the sorting
                    //  node.transition()
                    //     .duration(750)
                    //     .delay(function(d, i) { return i * 5; })
                    //     .attrTween("r", function(d) {
                    //         var i = d3.interpolate(0, d.radius);
                    //         return function(t) { return d.radius = i(t); };
                    //     });
                        
                        
                // Move d to be adjacent to the cluster node.
                function cluster(alpha) {
                    return function(d) {
                        var cluster = clusters[d.group];
                        if (cluster === d) return;
                        var x = d.x - cluster.x,
                            y = d.y - cluster.y,
                            l = Math.sqrt(x * x + y * y),
                            r = d.radius + cluster.radius;

                        if (l != r) {
                        l = (l - r) / l * alpha;
                        d.x -= x *= l;
                        d.y -= y *= l;
                        cluster.x += x;
                        cluster.y += y;
                        }
                    };
                }
                        
                function collide(alpha) {
                    var quadtree = d3.geom.quadtree(outArray);
                    return function(d) {
                        var r = d.radius + maxRadius + Math.max(padding, clusterPadding),
                            nx1 = d.x - r,
                            nx2 = d.x + r,
                            ny1 = d.y - r,
                            ny2 = d.y + r;
                        quadtree.visit(function(quad, x1, y1, x2, y2) {
                        if (quad.point && (quad.point !== d)) {
                            var x = d.x - quad.point.x //d.x , //changed this change back
                                y = d.y - quad.point.y,
                                l = Math.sqrt(x * x + y * y),
                                r = d.radius + quad.point.radius + (d.group === quad.point.cluster ? padding : clusterPadding);
                            if (l < r) {
                            l = (l - r) / l * alpha;
                            d.x -= x *= l;
                            d.y -= y *= l;
                            d.x = Math.max(d.radius, Math.min(width - d.radius, d.x))
                            d.y = Math.max(d.radius, Math.min(height - d.radius, d.y))
                            quad.point.x += x;
                            quad.point.y += y;
                            }
                        }
                        return x1 > nx2 || x2 < nx1 || y1 > ny2 || y2 < ny1;
                        });
                    };
                }


            // force.on("tick", function(e) {

            //     node
            //     .each(cluster(10 * e.alpha * e.alpha))
            //     .each(collide(.1))
            //     .attr("transform", function(d) { return "translate(" + Math.max(d.radius, Math.min(width - d.radius, d.x)) + "," + Math.max(d.radius, Math.min(height - d.radius, d.y)) + ")"; });       
            // });   
            
            window.addEventListener("resize", function() { 
                force.stop()
                var width = Math.max(320, window.innerWidth),
                    height = 1000,
                    mult = 320/width
                    
                // graph.nodes.forEach(function(d, i) {
                    
                //     graph.nodes[i].radius = Math.sqrt((d.radius*mult)/Math.PI*50) 

                //     if (!clusters[d.group] || (d.radius > clusters[d.group].radius)) 
                //         {
                //             clusters[d.group] = d;
                //         }
                //     maxRadius = Math.max(maxRadius, d.radius)
                // })
                // graph.nodes = graph.nodes.filter(function(d) {
                //     return d.radius > 0;
                // })
                
                // circles.data(graph.nodes).attr('r', function(d) {console.log(d.radius); return d.radius})
                
                force.size([width, height])

                d3.select('svg')
                    .attr("width", width)
                    .attr("height", height);


                force.on("tick", function(e) {

                    node
                    .each(cluster(10 * e.alpha * e.alpha))
                    .each(collide(.1))
                    .attr("transform", function(d) { return "translate(" + Math.max(d.radius, Math.min(width - d.radius, d.x)) + "," + Math.max(d.radius, Math.min(height - d.radius, d.y)) + ")"; });       
                });  
                                force.start()
            })
            
            function removeGroup() {

                node = svg.selectAll(".node")
                idArray.push(parseInt(this.id))

                newNodes = force.nodes().filter(function(d) {

                    return idArray.indexOf(d.group) != -1
                })
                
                node = node.data(newNodes, function(d) { return d.index;});
                //node.enter()
                node.exit().remove();

                node.enter().append('g')
                .attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; }) 
                .attr('class', 'node')
                .call(force.drag);
                
                node.append('circle')
                    .attr('r', function(d) {
                                return d.radius;
                            })
                            .style('fill', function(d) {
                                return color(d.group)
                            })
                    
                node.append('image')
                    .attr('xlink:href', function(d) {
                        
                        if (d.name.indexOf('.png') !== -1) {
                            return 'img-apple-160/' + d.name
                        }
                        else {
                            return null
                        }
                    })
                    .attr('width', function(d) {return d.radius + 'px'})
                    .attr('height', function(d) {return d.radius + 'px'})
                    .attr('x', function(d) {return -d.radius/2 + 'px'})
                    .attr('y', function(d) {return -d.radius/2 + 'px'})
                
                node.filter(function(d){
                        return d.name.indexOf('.png') === -1
                    })
                    .append('text')
                    .text(function(d) { return d.name;})
                    .attr('width', function(d) {return d.radius + 'px'})
                    .attr('height', function(d) {return d.radius + 'px'})
                    .attr('x', function(d) {return 0 + 'px'})
                    .attr('y', function(d) {return 5 + 'px'})
                    .style('font-size', '10px')
                    .attr('text-anchor', 'middle')
            
                force.on("tick", function(e) {

                    node
                    .each(cluster(10 * e.alpha * e.alpha))
                    .each(collide(.1))
                    .attr("transform", function(d) { return "translate(" + Math.max(d.radius, Math.min(width - d.radius, d.x)) + "," + Math.max(d.radius, Math.min(height - d.radius, d.y)) + ")"; });       
                });   
                force.start()
                        d3.selectAll('.node').on('click', function() {
            textArray = d3.select(this).datum().text
            console.log(textArray)
        })
                
                  
            }
            
            var idArray = []
            $('.button-hash').click(removeGroup)
                          
        })
    }
        
  build()
</script>